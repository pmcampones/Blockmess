package catecoin.validators;

import catecoin.exceptions.InputNotFoundException;
import catecoin.mempoolManager.MempoolManager;
import catecoin.mempoolManager.UTXOCollection;
import catecoin.txs.SlimTransaction;
import catecoin.utxos.SlimUTXO;
import catecoin.utxos.StorageUTXO;
import ledger.blocks.BlockContent;
import ledger.blocks.LedgerBlock;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import pt.unl.fct.di.novasys.babel.exceptions.HandlerRegistrationException;
import sybilResistantElection.SybilElectionProof;
import utils.IDGenerator;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toMap;

/**
 * Validates received blocks without accounting for their placement in relation with others.
 * <p>Useful for the majority of DLs; however may be lacking if we're using key/micro blocks.</p>
 */
public class ContextObliviousValidator<P extends SybilElectionProof> extends StatelessValidator<P> {

    private static final Logger logger = LogManager.getLogger(ContextObliviousValidator.class);

    public static final short ID = IDGenerator.genId();

    public final MempoolManager<?,P> mempoolManager;

    public ContextObliviousValidator(Properties props, MempoolManager<?,P> mempoolManager, SybilProofValidator<P> proofValidator)
            throws HandlerRegistrationException {
        this(props, mempoolManager, proofValidator, ID);
    }

    protected ContextObliviousValidator(Properties props, MempoolManager<?,P> mempoolManager, SybilProofValidator<P> proofValidator, short id)
            throws HandlerRegistrationException {
        super(props, ContextObliviousValidator.class.getSimpleName(), id, proofValidator);
        this.mempoolManager = mempoolManager;
    }

    @Override
    public void init(Properties properties) throws HandlerRegistrationException, IOException {}

    /**
     * Verifies if a signed block received as the argument is valid.
     * The validation is processed in three stages:
     *   1st:    The size of the block must not exceed the threshold established by the BlockConstructor
     *   2nd:    Is the verification of congruence of the block semantics.
     *           That is, do the signatures match and was the proposer honestly elected by the Sybil Election.
     *   3rd:    Is the verification that the UTXOs used were not forged.
     *           UTXOs are generated by consuming others,
     *           its necessary to check that all inputs exist and are being consumed for the first time,
     *           according with the view of the blocks received.
     *           The number of coins in the input and output must also match,
     *           and no node may use inputs belonging to another node.
     *
     *  The validation of whether the blocks reference correct previous blocks is responsibility of the Ledger component.
     **/
    public boolean receivedValid(LedgerBlock<BlockContent<SlimTransaction>, P> block) {
        return super.receivedValid(block)
                && areBlockInputsValid(block);
    }

    boolean areBlockInputsValid(LedgerBlock<BlockContent<SlimTransaction>, P> block) {
        try {
            mempoolManager.getMempoolReadLock().lock();
            return tryToCheckAreBlockInputsValid(block);
        } finally {
            mempoolManager.getMempoolReadLock().unlock();
        }
    }

    private boolean tryToCheckAreBlockInputsValid(LedgerBlock<BlockContent<SlimTransaction>, P> block) {
        List<UUID> prevStates = block.getPrevRefs();
        Set<UUID> invalidInMempool = aggregateInvalidMempoolUTXOs(prevStates);
        Set<StorageUTXO> validInMempool = aggregateValidMempoolUTXOs(prevStates, invalidInMempool);
        Map<UUID, StorageUTXO> mapValidInMempool = validInMempool.stream()
                .collect(toMap(StorageUTXO::getId, s -> s));
        return block.getBlockContent().getContentList().parallelStream()
                .allMatch(tx -> areTransactionInputsValid(tx, invalidInMempool, mapValidInMempool));
    }

    private boolean areTransactionInputsValid(SlimTransaction tx, Set<UUID> invalid,
                                              Map<UUID, StorageUTXO> validInMempool) {
        try {
            return tryToVerifyAreTransactionInputsValid(tx, invalid, validInMempool);
        } catch (InputNotFoundException e) {
            logger.info("Could not verify validity of inputs because: '{}'", e.getMessage());
        }
        return false;
    }

    private boolean tryToVerifyAreTransactionInputsValid(SlimTransaction tx, Set<UUID> invalid,
                                                         Map<UUID, StorageUTXO> validInMempool)
            throws InputNotFoundException {
        Set<StorageUTXO> inputUtxos = getTxStorageUtxos(tx, invalid, validInMempool);
        return inputUtxos.stream().allMatch(utxo -> utxo.getUTXOOwner().equals(tx.getOrigin()))
                && transactionAmountsMatch(inputUtxos, tx);
    }

    private Set<StorageUTXO> getTxStorageUtxos(SlimTransaction tx, Set<UUID> invalid,
                                               Map<UUID, StorageUTXO> validInMempool)
            throws InputNotFoundException {
        Set<StorageUTXO> inputUtxos = new HashSet<>(tx.getInputs().size());
        Collection<Optional<StorageUTXO>> finalizedUtxos = UTXOCollection.getUtxos(tx.getInputs());
        Iterator<Optional<StorageUTXO>> finalizedUtxosIt = finalizedUtxos.iterator();
        Iterator<UUID> inputsIt = tx.getInputs().iterator();
        while (finalizedUtxosIt.hasNext()) {
            Optional<StorageUTXO> finalizedUtxo = finalizedUtxosIt.next();
            UUID input = inputsIt.next();
            StorageUTXO inputUtxo = finalizedUtxo.orElse(validInMempool.get(input));
            if (invalid.contains(input) || inputUtxo == null)
                throw new InputNotFoundException(input);
            inputUtxos.add(inputUtxo);
        }
        return inputUtxos;
    }

    private boolean transactionAmountsMatch(Set<StorageUTXO> input, SlimTransaction tx) {
        return input.stream()
                .mapToInt(StorageUTXO::getAmount).sum() ==
                Stream.concat(tx.getOutputsDestination().stream(), tx.getOutputsOrigin().stream())
                .mapToInt(SlimUTXO::getAmount).sum();
    }

    private Set<UUID> aggregateInvalidMempoolUTXOs(Collection<UUID> previousStates) {
        Set<UUID> invalid = new HashSet<>();
        Set<UUID> visited = new HashSet<>();
        previousStates.forEach(id -> invalid.addAll(mempoolManager.getInvalidUtxosFromChunk(id, visited)));
        return invalid;
    }

    private Set<StorageUTXO> aggregateValidMempoolUTXOs(Collection<UUID> mempooolIds, Set<UUID> excluded) {
        Set<StorageUTXO> valid = new HashSet<>();
        Set<UUID> visited = new HashSet<>();
        mempooolIds.forEach(id -> valid.addAll(mempoolManager.getAddedUtxosFromChunk(id, visited)));
        return valid.stream().filter(utxo -> !excluded.contains(utxo.getId())).collect(Collectors.toSet());
    }

}
